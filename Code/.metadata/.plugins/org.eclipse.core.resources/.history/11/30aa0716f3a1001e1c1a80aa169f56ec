/*
 * app_coap.h
 *
 *  Created on: Jun 2, 2023
 *      Author: edward62740
 */

#ifndef APP_COAP_H_
#define APP_COAP_H_

#ifdef __cplusplus
extern "C" {
#endif

#include <openthread/coap.h>
#include "openthread/ip6.h"
#include "app_main.h"

typedef enum {
	MSG_LIMITED_SPECTRUM, MSG_FULL_SPECTRUM, MSG_ALIVE,
} app_msg_t;

const uint16_t COAP_MAX_PAYLOAD_LENGTH = 64U; // max entries of X(k)
const uint16_t COAP_MAX_ITEM_SIZE = sizeof(uint32_t) + sizeof(uint16_t);
const uint16_t COAP_MAX_PAYLOAD_SIZE = COAP_MAX_ITEM_SIZE
		* COAP_MAX_PAYLOAD_LENGTH; // size of COAP_MAX_PAYLOAD_LENGTH in bytes
const static char *ack = "ack";
const static char *nack = "nack";

class coapSender {

public:
	coapSender();
	~coapSender();
	otIp6Address selfAddr;
	otIp6Address brAddr;
	bool appCoapConnectionEstablished = false; // indicates that the "connection" with upstream server is active
	char resource_name[32];

	char payload_buf[COAP_MAX_PAYLOAD_SIZE];

	otCoapResource mResource_PERMISSIONS;

#define PERMISSIONS_URI "permissions"
	const char *mPERMISSIONSUriPath = PERMISSIONS_URI;

	uint32_t appCoapFailCtr = 0;
	uint32_t appCoapSendTxCtr = 0;
	const uint8_t device_type = 2U;



	void permissionsHandler(void *aContext, otMessage *aMessage,
			const otMessageInfo *aMessageInfo);
	bool checkBuffer(void);
	bool send(char *payload, bool require_ack);
	bool parseIntoBuffer(app_data_t *data, app_msg_t type);
	bool checkConnectionValid(void);

private:

	static void permissionsHandlerStaticWrapper(void *ctx, otMessage *msg,
			const otMessageInfo *msgInfo) {
		coapSender *instance = static_cast<coapSender*>(ctx);
		instance->permissionsHandler(ctx, msg, msgInfo);
	}
};
#ifdef __cplusplus
}
#endif /* __cplusplus */

#endif /* APP_COAP_H_ */
